# E-Graph基本原理与简单实现

本文内容基于以下网络博客与论文：

> The E-Graph Data Structure - A Gradual Introduction

## 表达式优化问题

我们有一些可以应用在符号表达式上的优化重写规则，例如
+ [1]`(* x 1) => x`
+ [2]`(* x 2) => (<< x 1)`
+ [3]`(/ x x) => 1`(此处不考虑除零之类的)
+ [4]`(/ (* x y) z) => (* x (/ y z))`

怎样得到最优解？(此处不追究最优的严格定义)

可以采取一种广度优先搜索的方法, 首先尝试对目标表达式应用每一条规则

> 规则应用是递归的，最外面一层不行可以继续往下尝试

以`(/ (* a 2) 2)`为例，应用上面4条规则后得到这样的表达式列表:

```
(/ (<< x 1) 2)
(* a (/ 2 2))
```

然后我们继续在这个列表上迭代应用，发现`(/ (<< x 1) 2)`没有优化空间了，但`(* a (/ 2 2))`还可以通过规则4重写成`(* a 1)`, 我们把结果放回列表，重复上述迭代，最终结果是

```
(/ (<< x 1) 2)
(* a (/ 2 2))
(* a 1)
a
```

最终得到最优结果: `a`

这个方法的问题很明显。随着规则增多和输入表达式大小的膨胀，候选列表和列表中中间表达式也会大到影响程序的内存占用和运行时间。

## E-Graph

E-Graph对此问题的优化思路来源于两种技术: 并查集与hash-consing。

在hash-consing的基础上，E-Graph会利用给定的重写规则进行进一步的压缩，它会把重写规则看作某种等价关系，进而导出E-Class