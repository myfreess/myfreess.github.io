近日打算捡起一年多没搞的codewars，然后因为这学期要学操作系统和计算机组成原理，想熟悉一下汇编，于是打算写写NASM。

然后懵了，因为我没学过汇编，看到nasm的测试代码是用C写的，有点没反应过来。好在之前看levity polymorphism的时候接触到调用约定(calling convention)这个概念(有限的关于硬件的知识基本都是看函数式材料学的......), 于是弄了份pdf，看一下x86-64(有时也叫AMD64)上的调用约定(就先限于C)

调用约定据说是让不同语言的二进制文件间的互操作性增强了，那我权且相信。

下文的子例程(subroutine)就是C的函数，应该是这样吧。

**调用者的规则(prologue)：**

+ 在子例程调用前，保存r10，r11，以及所有用于传参的寄存器的内容(入栈)。如果子例程调用之后恢复上下文，就放到栈上。

+ 子例程的前六个参数按顺序放进`rdi rsi rdx rcx r8 r9`，剩下的逆序放到栈上(最后一个参数第一个进栈)。在栈向下的增长完成之后，第七个参数会被放在最低位的地址(逆序在历史上曾用于支持可变参数，大概因为x86和C都是热衷于兼容的也便留下来了。)
  
+ 用call指令调用子例程，它会把返回的地址放在栈顶，然后切换到子例程。

+ 在子例程返回后，调用者必须把放在栈上的额外参数全部弹出，将状态复位到调用前。

+ 调用者可以期待在RAX寄存器中得到子例程的返回值。

+ 把子例程调用前保存的寄存器内容从栈中弹出并复位。调用者可以假设子例程没修改过其他寄存器。

**被调用者守则(epilogue)：**

+ 内部变量要么分配个寄存器，要么在栈上弄块空间。再重复一遍，栈是向下增长的，所以在栈顶放东西占用了空间之后要把栈指针递减.至于具体要减多少，得看用了多少内部变量。举例，如果有一个float和一个long(共占12字节)，那就应该

  ```assembly
  sub rsp, 12
  ```

+ RBX，RBP，R12 - R15是被调用者有义务去保存内容的寄存器，当然了，还是放到栈顶。RSP按照调用约定也应该被保护，但是并不需要将其内容推入栈。

+ 返回值应该放在RAX寄存器中。

+ 之前保存的寄存器内容应当从栈中弹出并复位。

+ 将RSP的内容(栈指针)恢复到原值。

+ 通过ret指令返回。

不过呢，如果去看一些C编译器的中间产物，也许会在子例程的前部看到一些额外的指令

```assembly
; 被调用者开始
push rbp
mov rbp, rsp
......
; 在ret前
pop rbp
```

这是从32位的调用约定套来的一个历史遗留，可以通过`-fomit-frame-pointer`这个flag去除这些冗余代码。

一切都结束了？

并没有，这份材料毕竟是用于教学的，经查询，它是所谓的**System V ABI**(调用约定有时也叫ABI(Application Binary Interface, 应用二进制接口))的一个子集，System V是一组在Unix类系统上通行的调用约定，Linux和Mac都用。

那Windows呢？

事情不太妙，查询windows官方文档发现，Windows上有好几种现今仍在使用的ABI，有社区的巨佬调侃称这就是不同C++方言。最官方的应该是所谓的Microsoft ABI -- FASTCALL 调用约定的一个变体，但是同时存在的还有cdecl，STDCALL，VECTORCALL。我也不明白为什么有这些玩意，大概是调用较老接口用的吧。

当然了，System V ABI远没有上面那么简单，0.99.6版草稿足有128页了，可见有太多琐碎的细节都在上面省去了。