# 抽象解释视角下的静态分析

> Introduction to Static Analysis : An Abstract Interpretation Perspective 读书笔记

## 1.程序分析

### 1.1 理解程序的行为

程序的语义是对程序运行时表现的形式化描述

### 1.2 程序分析的应用与挑战

### 1.3 程序分析中的概念

#### 1.3.1 分析什么？

第一个问题是分析什么样的程序，以及希望分析它们的什么性质

##### 根据目标程序分类

+ 领域特定程序分析
  例如嵌入式程序很少使用C语言的复杂特性，让程序分析简单了很多。

+ 非领域特定程序分析

##### 根据分析器输入分类

+ 程序级别分析
  
+ 模型级别分析

##### 根据目标性质分类

+ 安全性质
+ 活跃性质
+ 信息流性质

#### 1.3.2 静态与动态之争

+ 用户断言
+ 静态类型

#### 1.3.3 硬性限制：不可计算性

根据rice定理，任何非显然的语义性质都不能设计出一个对任意程序p可以绝对准确地判断其是否有该性质的算法。

有用的程序分析技术必须做出取舍。

#### 1.3.4 自动化与可扩展性

围绕rice定理所作出的第一种妥协是让用户在分析过程中输入一些提示信息

#### 1.3.5 近似：可靠性与完备性

### 1.4 程序分析技术家族

### 1.4.1 测试：有限执行集检查

### 1.4.2 辅助证明：依赖于用户提供不变量

### 1.4.3 模型检查：遍历有限系统

### 1.4.4 保守静态分析

### 1.4.5 寻找Bug

### 1.5 路线图

## 2.静态分析简介

### 2.1 语义与分析目标：可达性问题

### 2.2 抽象

### 2.3 可计算的抽象语义：组合风格

### 2.4 可计算的抽象语义：转移风格

### 2.5 静态分析的核心原则

## 3.基于组合语义的静态分析框架

### 3.1 语义

### 3.2 抽象

### 3.3 可计算的抽象语义

### 3.4 抽象解释器的设计

## 4.基于转移语义的静态分析框架

### 4.1 语义作为状态转移

### 4.2 抽象语义作为抽象状态转移

### 4.3 基于全局迭代的分析算法

### 4.4 用例

## 5.更完善的静态分析技术

### 5.1 构造抽象域

### 5.2 完善的迭代技术

### 5.3 稀疏分析

### 5.4 模块化分析

### 5.5 后向分析

## 6.静态分析工具的实用用途

### 6.1 分析假设与目标

### 6.2 设置一个程序的静态分析

### 6.3 检查分析结果

### 6.4 部署一个静态分析工具

## 7.静态分析工具实现

### 7.1 具体语义与具体解释器

### 7.2 抽象域实现

### 7.3 表达式与条件的静态分析

### 7.4 基于组合语义的静态分析

### 7.5 基于转移语义的静态分析

## 8.面向工业语言的静态分析

### 8.1 对于有指针和动态内存分配的语言

### 8.2 对于有函数和递归调用的语言

### 8.3 数据结构抽象

### 8.4 控制结构抽象

## 9.语义性质分类以及通过静态分析进行验证

### 9.1 迹性质

### 9.2 超越迹性质: 信息流与其他性质

## 10.特化的静态分析框架

### 10.1 基于等式的静态分析

### 10.2 基于单调闭包的静态分析

### 10.3 基于证明构造的静态分析

## 11.总结

